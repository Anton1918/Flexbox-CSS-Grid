1. У чому різниця між Flexbox і Grid?

Основна різниця полягає в вимірності та призначенні:

Flexbox — це одновимірна система компоновки. Вона розташовує елементи вздовж однієї осі — або горизонтально (головна вісь), або вертикально (поперечна вісь). Вона ідеально підходить для компонентів інтерфейсу, де потрібно динамічно розподіляти простір всередині контейнера.
 CSS Grid — це двовимірна система компоновки. Вона працює одночасно з рядками та стовпцями, дозволяючи створювати складні макети з точним позиціонуванням елементів в обох вимірах. Вона призначена для розмітки всієї сторінки або великих її частин.


2. Коли доцільніше використовувати Flexbox, а коли Grid?

    Використовуйте Flexbox для:
Одновимірних макетів: Компонування елементів в один рядок або один стовпець (наприклад, навігаційна панель, ряд кнопок, картка товару).
Вирівнювання та розподілу простору: Коли вам потрібно гнучко вирівняти елементи або розподілити вільний простір між ними всередині контейнера.
Компонентів інтерфейсу: Меню, сайдбари, галереї зображень, де контент може динамічно змінювати розмір.

    Використовуйте CSS Grid для:
Двовимірних макетів: Створення загальної структури сторінки з областями заголовка, сайдбара, основного контенту та футера.
Складних, регулярних макетів: Коли вам потрібен точний контроль над розташуванням елементів по стовпцях і рядках одночасно (наприклад, сітка зображень, інформаційна панель).
Макетів, де потрібно "перестрибувати" через елементи: Grid дозволяє елементам займати кілька рядків або стовпців, що робить його ідеальним для нестандартних розташувань.


3. Як задати вирівнювання елементів по вертикалі у Flexbox?

Для вирівнювання елементів по вертикалі у Flexbox використовується властивість align-items для всіх елементів контейнера одразу або align-self для окремого елемента.

Властивість контейнера: align-items
.container {
  display: flex;
  align-items: stretch; /* За замовчуванням: розтягує елементи на всю висоту */
  align-items: flex-start; /* Елементи вирівнюються по верхньому краю */
  align-items: center;    /* Елементи вирівнюються по центру */
  align-items: flex-end;  /* Елементи вирівнюються по нижньому краю */
  align-items: baseline;  /* Елементи вирівнюються по базовій лінії тексту */
}

Властивість окремого елемента: align-self
Ця властивість дозволяє перевизначити align-items для окремого елемента.

.item {
  align-self: auto | flex-start | center | flex-end | baseline | stretch;
}


4. Як працюють шаблони grid-template-columns та grid-template-areas?

grid-template-columns визначає кількість стовпців у сітці та їх ширину.

.grid-container {
  display: grid;
  grid-template-columns: 200px 1fr 100px; /* Три стовпці: 200px, що займає вільний простір, 100px */
  grid-template-columns: repeat(3, 1fr); /* Три стовпці однакової ширини */
  grid-template-columns: 1fr minmax(300px, 2fr); /* Другий стовпець мінімум 300px, максимум 2fr */
}

grid-template-areas дозволяє дати імена областям сітки та візуально описати макет за допомогою ASCII-арту.

.grid-container {
  display: grid;
  grid-template-columns: 1fr 3fr;
  grid-template-rows: auto 1fr auto;
  grid-template-areas:
    "header header"
    "sidebar main"
    "footer footer";
}

.header { grid-area: header; }
.sidebar { grid-area: sidebar; }
.main { grid-area: main; }
.footer { grid-area: footer; }

Кожен рядок у лапках представляє рядок сітки, а кожне слово — комірку. Повторення назви області на сусідніх комірках об'єднує їх в одну область.


5. Як організувати спільну роботу з Git і уникнути конфліктів під час злиття?

    Часова синхронізація: Часто виконуйте git pull (або git fetch + git rebase), щоб ваша локальна гілка була актуальною відносно віддаленого репозиторію.

    Робота у власних гілках: Ніколи не працюйте безпосередньо в гілці main або develop. Створюйте для кожної нової функції чи виправлення окрему гілку (feature branch).

    Дрібні коміти: Робіть невеликі, логічно завершені коміти з чіткими повідомленнями. Це полегшує аналіз історії та вирішення конфліктів.

    Часті пуши: Регулярно публікуйте свої зміни в віддалений репозиторій (git push). Це дозволяє колегам бачити вашу роботу і зменшує розбіжності в коді.

    Уважне планування Pull/Merge Request: Перед створенням запиту на злиття:

        Переконайтеся, що ваша гілка синхронізована з цільовою гілкою (git merge main або git rebase main).

        Виконайте тестування.

        Перегляньте свій власний код.

    Чіткий процес Code Review: Обов'язковий ревью коду колегами перед злиттям допомагає знайти помилки та покращити якість коду.

    Використання інструментів: Якщо конфлікт все ж таки стався, використовуйте інструменти для його вирішення (вбудовані в IDE, як-от VS Code, або спеціалізовані, як meld, kdiff3). Уважно аналізуйте пропозиції Git, прибираючи маркери конфлікту (<<<<<<<, =======, >>>>>>>) і залишаючи потрібний код.
